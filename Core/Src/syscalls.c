/**
 ******************************************************************************
 * @file      syscalls.c
 * @author    Auto-generated by STM32CubeIDE
 * @brief     STM32CubeIDE Minimal System calls file
 *
 *            For more information about which c-functions
 *            need which of these lowlevel functions
 *            please consult the Newlib libc-manual
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2020-2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

/* Includes */
#include <sys/stat.h>
#include <stdlib.h>
#include <errno.h>
#include <stdio.h>
#include <signal.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>
#include "usbd_cdc_acm_if.h"
#include "usb_device.h"

/* Variables */
extern int __io_putchar(int ch) __attribute__((weak));
extern int __io_getchar(void) __attribute__((weak));


char *__env[1] = { 0 };
char **environ = __env;


/* Functions */
void initialise_monitor_handles()
{
}

int _getpid(void)
{
  return 1;
}

int _kill(int pid, int sig)
{
  (void)pid;
  (void)sig;
  errno = EINVAL;
  return -1;
}

void _exit (int status)
{
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    *ptr++ = __io_getchar();
  }

  return len;
}

// The user-provided buffer
char write_buffer[64];
// Static variable to keep track of the current number of bytes in write_buffer
static int buffer_current_size = 0;

// Helper function to flush the write_buffer via CDC_Transmit
// Returns:
//   Number of bytes successfully flushed.
//   -1 on critical error (e.g., USB not configured, or CDC_Transmit critical failure).
//   0 if no bytes were flushed but no critical error (e.g., CDC endpoint busy/NACK).
static int _internal_flush_buffer() {
    if (buffer_current_size == 0) {
        return 0; // Nothing to flush
    }

    if (hUsbDevice.dev_state != USBD_STATE_CONFIGURED) {
        return -1; // Cannot transmit if USB not configured
    }

    // Attempt to transmit the entire buffer content
    uint8_t status;

    unsigned int iterations = 0;
    do {
    	 status = CDC_Transmit(0, (const uint8_t*)write_buffer, buffer_current_size);
    	 if (status == USBD_BUSY) HAL_Delay(10);
    	 iterations++;
    } while (status == USBD_BUSY && iterations < 20);

    if (iterations == 20) return -1;

    if (status != USBD_OK) { // CDC_Transmit reported a critical error
        return -1;
    }
    else {
        int flushed_amount = buffer_current_size;
        buffer_current_size = 0; // Reset buffer
        return flushed_amount;
    }
}

// --- ANSI Color Code Definitions ---
// We define these for clarity and easy modification.
#define ANSI_COLOR_RED     "\x1b[31m"
#define ANSI_COLOR_RESET   "\x1b[0m"

/**
 * @brief Low-level write function for printf, puts, etc.
 * This version colorizes stderr output (file descriptor 2) in red.
 */
__attribute__((weak)) int _write(int file, char *ptr, int len) {
    // We only handle stdout (1) and stderr (2)
    if (file != 1 && file != 2) {
        errno = EBADF;
        return -1;
    }

    // If USB is not ready, we cannot proceed.
    if (hUsbDevice.dev_state != USBD_STATE_CONFIGURED && buffer_current_size == 0) {
        errno = EIO;
        return -1;
    }

    // --- Start of new logic for colorization ---
    // If the file is stderr, write the RED color code to the buffer first.
    if (file == 2) {
        const char* color_code = ANSI_COLOR_RED;
        int code_len = strlen(color_code);
        for (int i = 0; i < code_len; i++) {
            write_buffer[buffer_current_size] = color_code[i];
            buffer_current_size++;
            // If adding the code fills the buffer, flush it.
            if (buffer_current_size == sizeof(write_buffer)) {
                if (_internal_flush_buffer() < 0) {
                    errno = EIO;
                    return -1; // Critical flush error
                }
            }
        }
    }
    // --- End of new logic for colorization ---

    int input_bytes_processed = 0;
    for (int i = 0; i < len; i++) {
        // Add current character from input ptr to our write_buffer
        write_buffer[buffer_current_size] = ptr[i];
        buffer_current_size++;
        input_bytes_processed++;

        int flush_needed = 0;
        if (buffer_current_size == sizeof(write_buffer)) {
            flush_needed = 1; // Buffer is full
        } else if (ptr[i] == '\n' && (file == 1 || file == 2)) {
            flush_needed = 1; // Newline character encountered
        }

        if (flush_needed) {
            int buffer_size_before_flush_attempt = buffer_current_size;
            int flushed_bytes_count = _internal_flush_buffer();

            if (flushed_bytes_count < 0) {
                errno = EIO;
                return -1;
            }

            if (buffer_size_before_flush_attempt == sizeof(write_buffer) && flushed_bytes_count == 0) {
                buffer_current_size--;
                input_bytes_processed--;
                errno = EAGAIN;
                return input_bytes_processed;
            }
        }
    }

    // --- Start of new logic for colorization ---
    // If the file is stderr, write the RESET color code to the buffer afterward.
    if (file == 2) {
        const char* color_code = ANSI_COLOR_RESET;
        int code_len = strlen(color_code);
        for (int i = 0; i < code_len; i++) {
            write_buffer[buffer_current_size] = color_code[i];
            buffer_current_size++;
            // If adding the code fills the buffer, flush it.
            if (buffer_current_size == sizeof(write_buffer)) {
                if (_internal_flush_buffer() < 0) {
                    errno = EIO;
                    return -1; // Critical flush error
                }
            }
        }
        // Force a flush after an error message. This ensures the color is
        // reset in the terminal immediately, even if the error message
        // didn't end with a newline.
        _internal_flush_buffer();
    }
    // --- End of new logic for colorization ---

    _internal_flush_buffer();
    return input_bytes_processed;
}

int _close(int file)
{
  (void)file;
  return -1;
}


int _fstat(int file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _isatty(int file)
{
  (void)file;
  return 1;
}

int _lseek(int file, int ptr, int dir)
{
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
}

int _open(char *path, int flags, ...)
{
  (void)path;
  (void)flags;
  /* Pretend like we always fail */
  return -1;
}

int _wait(int *status)
{
  (void)status;
  errno = ECHILD;
  return -1;
}

int _unlink(char *name)
{
  (void)name;
  errno = ENOENT;
  return -1;
}

int _times(struct tms *buf)
{
  (void)buf;
  return -1;
}

int _stat(char *file, struct stat *st)
{
  (void)file;
  st->st_mode = S_IFCHR;
  return 0;
}

int _link(char *old, char *new)
{
  (void)old;
  (void)new;
  errno = EMLINK;
  return -1;
}

int _fork(void)
{
  errno = EAGAIN;
  return -1;
}

int _execve(char *name, char **argv, char **env)
{
  (void)name;
  (void)argv;
  (void)env;
  errno = ENOMEM;
  return -1;
}
